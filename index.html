<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SPACE ESCAPE: THE VOID</title>
    <style>
        /* --- CSS STYLES --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Critical for game, but handled carefully in JS */
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay Layer */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #00f3ff;
            text-shadow: 0 0 10px #00f3ff;
            font-size: 1.2rem;
            font-weight: bold;
            width: 100%;
            box-sizing: border-box;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto; /* Re-enable pointer events for UI */
            backdrop-filter: blur(5px);
            z-index: 10;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        h1 {
            color: #ff0055;
            font-size: 2.5rem;
            text-shadow: 0 0 20px #ff0055, 4px 4px 0px #00f3ff;
            margin-bottom: 5px;
            text-align: center;
            letter-spacing: 2px;
            font-style: italic;
        }

        p.sub {
            color: #fff;
            font-size: 0.9rem;
            margin-bottom: 20px;
            opacity: 0.8;
            text-align: center;
        }

        /* Buttons */
        button {
            background: linear-gradient(45deg, #ff0055, #ff5e00);
            border: none;
            padding: 20px 50px; /* Larger touch target */
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.6);
            border-radius: 4px;
            transform: skew(-10deg);
            transition: transform 0.1s, box-shadow 0.1s;
            margin-bottom: 15px;
            touch-action: manipulation; /* Allow clicks */
            pointer-events: auto;
        }

        button:active {
            transform: skew(-10deg) scale(0.95);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.8);
        }
        
        button:disabled {
            background: #555;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        .secondary-btn {
            background: transparent;
            border: 2px solid #555;
            box-shadow: none;
            font-size: 0.9rem;
            padding: 15px 30px;
            color: #aaa;
            margin-top: 10px;
        }

        /* Leaderboard styling */
        .leaderboard-container {
            width: 90%;
            max-width: 450px;
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid #00f3ff;
            padding: 15px;
            border-radius: 8px;
            max-height: 40vh;
            overflow-y: auto;
            /* Allow scrolling inside leaderboard on mobile */
            -webkit-overflow-scrolling: touch; 
            touch-action: pan-y; 
        }
        
        .lb-header {
            text-align: center;
            color: #00f3ff;
            margin-bottom: 10px;
            font-size: 1.1rem;
            border-bottom: 2px solid #00f3ff;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .lb-row { 
            display: flex; 
            justify-content: space-between; 
            color: white; 
            margin-bottom: 8px; 
            font-size: 0.85rem; 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            padding-bottom: 2px;
        }
        
        .lb-row span:nth-child(1) { width: 40%; text-align: left; color: #ff0055; font-weight: bold; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } 
        .lb-row span:nth-child(2) { width: 30%; text-align: right; color: #aaa; } 
        .lb-row span:nth-child(3) { width: 30%; text-align: right; color: #fff; } 

        input#playerName {
            background: transparent;
            border: 2px solid #00f3ff;
            padding: 15px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            text-align: center;
            margin: 20px 0;
            outline: none;
            width: 80%;
            max-width: 300px;
            pointer-events: auto;
        }

        .mobile-controls-hint {
            position: absolute;
            bottom: 50px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
            opacity: 0.3;
            pointer-events: none;
        }
        .tap-zone {
            width: 80px;
            height: 80px;
            border: 2px dashed #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8rem;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="uiLayer">
        <div class="hud-top">
            <div id="scoreDisplay">SCORE: 0</div>
            <div id="timeDisplay">TIME: 00:00</div>
        </div>
        <div class="mobile-controls-hint">
            <div class="tap-zone">HOLD<br>LEFT</div>
            <div class="tap-zone">HOLD<br>RIGHT</div>
        </div>
    </div>

    <div id="homeScreen" class="screen">
        <h1>SPACE<br>ESCAPE</h1>
        <button id="startBtn">Enter The Void</button>
        <div class="leaderboard-container">
            <div class="lb-header">
                <span style="width:40%; text-align:left;">PILOT</span>
                <span style="width:30%; text-align:right;">TIME</span>
                <span style="width:30%; text-align:right;">SCORE</span>
            </div>
            <div id="leaderboardList">Loading Data...</div>
        </div>
        <p class="sub" style="margin-top: 10px;">TOUCH SIDES TO STEER</p>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <h1>CRASHED</h1>
        <p class="sub" id="finalScoreMsg">SCORE: 0</p>
        <p class="sub" id="finalTimeMsg">TIME: 00:00</p>
        
        <p class="sub">ENTER PILOT NAME</p>
        <input type="text" id="playerName" placeholder="Your Name" maxlength="12">
        
        <button id="saveBtn">SAVE & HOME</button>
        <button id="discardBtn" class="secondary-btn">DISCARD & HOME</button>
        
        <p class="sub" style="font-size: 0.7rem; color: #ff5e00; cursor: pointer; margin-top: 10px;" onclick="location.reload()">Refresh if stuck</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD6aJcB0WtFTDUcHLi1v5YeyG54DwgVJNU",
            authDomain: "neondrift-71d9e.firebaseapp.com",
            projectId: "neondrift-71d9e",
            storageBucket: "neondrift-71d9e.firebasestorage.app",
            messagingSenderId: "240164176604",
            appId: "1:240164176604:web:a8b4c6544914e72be0aa19",
            measurementId: "G-XX0ZEBG9EN"
        };

        let db;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            fetchLeaderboard();
        } catch (e) {
            console.error("Firebase Error:", e);
            document.getElementById('leaderboardList').innerHTML = "Offline Mode";
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let gameActive = false;
        let score = 0;
        let speed = 0;
        let frameCount = 0;
        let startTime = 0;
        let finalTimeString = "00:00";
        
        let particles = [];
        let shockwaves = [];
        let obstacles = [];
        let coins = [];
        let gridOffset = 0;
        
        const player = { x: 0, y: 0, width: 40, height: 60, color: '#00f3ff', tilt: 0 };
        const input = { left: false, right: false };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 150;
            player.x = canvas.width / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- GLOBAL TOUCH HANDLER (FIXED) ---
        // This handles game controls AND ensures UI buttons are clickable
        const handleGlobalTouch = (e) => {
            // Check if the user touched a button or input field
            const target = e.target;
            if (target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.closest('.leaderboard-container')) {
                return; // Let default browser behavior handle clicks/inputs
            }

            // Otherwise, treat as Game Control and prevent default (scrolling)
            if (e.type !== 'touchend') {
                e.preventDefault(); 
            }
            
            // Game Input Logic
            if (!gameActive) return;

            input.left = false; 
            input.right = false;
            
            if (e.type === 'touchend') return; // Stop movement on release

            const touches = e.touches;
            const midPoint = window.innerWidth / 2;
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].clientX < midPoint) input.left = true;
                else input.right = true;
            }
        };

        // Attach listeners with passive: false to allow preventDefault
        document.addEventListener('touchstart', handleGlobalTouch, { passive: false });
        document.addEventListener('touchmove', handleGlobalTouch, { passive: false });
        document.addEventListener('touchend', handleGlobalTouch, { passive: false });

        // Keyboard (Desktop)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') input.left = true;
            if (e.key === 'ArrowRight') input.right = true;
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') input.left = false;
            if (e.key === 'ArrowRight') input.right = false;
        });

        function startGame(e) {
            // Prevent double firing if both touch/click register
            if (e && e.cancelable) e.preventDefault(); 
            
            if (gameActive) return;
            gameActive = true;
            score = 0;
            speed = 8;
            frameCount = 0;
            startTime = Date.now();
            
            obstacles = [];
            coins = [];
            particles = [];
            shockwaves = [];
            player.x = canvas.width / 2;
            
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            gameLoop();
        }

        function gameOver() {
            if (!gameActive) return;
            gameActive = false;
            
            createExplosion(player.x, player.y, 150, '#00f3ff');
            createExplosion(player.x, player.y, 50, '#ff5e00');
            shockwaves.push({ x: player.x, y: player.y, r: 1, alpha: 1, color: '#fff' });
            
            draw(); 
            
            setTimeout(() => {
                document.getElementById('gameOverScreen').classList.remove('hidden');
                document.getElementById('finalScoreMsg').innerText = `SCORE: ${Math.floor(score)}`;
                document.getElementById('finalTimeMsg').innerText = `TIME: ${finalTimeString}`;
            }, 1000);
        }

        function update() {
            frameCount++;
            score += 0.1;
            
            if (frameCount % 500 === 0) speed += 0.5;

            const elapsed = Date.now() - startTime;
            const mins = Math.floor(elapsed / 60000);
            const secs = Math.floor((elapsed % 60000) / 1000);
            finalTimeString = `${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('timeDisplay').innerText = `TIME: ${finalTimeString}`;

            const moveSpeed = 7 + (speed * 0.1);
            if (input.left) { player.x -= moveSpeed; player.tilt = -15; }
            else if (input.right) { player.x += moveSpeed; player.tilt = 15; }
            else { player.tilt = 0; }

            if (player.x < player.width/2) player.x = player.width/2;
            if (player.x > canvas.width - player.width/2) player.x = canvas.width - player.width/2;

            const spawnRate = Math.max(10, 60 - Math.floor(speed * 2.5));
            
            if (frameCount % spawnRate === 0) {
                const size = Math.random() * 40 + 30;
                const rand = Math.random();
                let type = 0; 
                if (rand > 0.6) type = 1; 
                if (rand > 0.85) type = 2; 

                obstacles.push({
                    x: Math.random() * (canvas.width - size),
                    y: -100,
                    w: size,
                    h: size,
                    active: true,
                    type: type,
                    angle: 0, 
                    startX: obstacles.length 
                });
                obstacles[obstacles.length-1].startX = obstacles[obstacles.length-1].x;
            }

            if (frameCount % 150 === 0) {
                coins.push({ x: Math.random() * (canvas.width - 30), y: -100, size: 15, active: true });
            }

            obstacles.forEach(obs => {
                obs.y += speed;
                
                if (obs.type === 1) { // WEAVER
                   obs.x = obs.startX + Math.sin(frameCount * 0.05) * 50;
                   if(obs.x < 0) obs.x = 0;
                   if(obs.x > canvas.width - obs.w) obs.x = canvas.width - obs.w;
                }
                else if (obs.type === 2) { // SPINNER
                    obs.angle += 0.1; 
                }

                if (obs.active && 
                    player.x - player.width/2 < obs.x + obs.w && 
                    player.x + player.width/2 > obs.x && 
                    player.y - player.height/2 < obs.y + obs.h && 
                    player.y + player.height/2 > obs.y) {
                    gameOver();
                }
            });

            coins.forEach(c => {
                c.y += speed;
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                if (c.active && Math.sqrt(dx*dx + dy*dy) < player.width/2 + c.size) {
                    c.active = false;
                    score += 50;
                    createExplosion(c.x, c.y, 10, '#ffd700');
                }
            });

            obstacles = obstacles.filter(o => o.y < canvas.height + 100);
            coins = coins.filter(c => c.y < canvas.height + 100);
            
            particles.forEach(p => { 
                p.x += p.vx; p.y += p.vy; p.life -= 0.02; 
            });
            particles = particles.filter(p => p.life > 0);

            shockwaves.forEach(s => {
                s.r += 15; s.alpha -= 0.05; 
            });
            shockwaves = shockwaves.filter(s => s.alpha > 0);

            document.getElementById('scoreDisplay').innerText = `SCORE: ${Math.floor(score)}`;
        }

        function createExplosion(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 15;
                particles.push({ 
                    x: x, y: y, vx: Math.cos(angle) * velocity, vy: Math.sin(angle) * velocity, life: 1, color: color 
                });
            }
        }

        function draw() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            gridOffset = (gridOffset + speed) % 50;
            ctx.strokeStyle = 'rgba(163, 21, 163, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i <= canvas.width; i += 50) { ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); }
            for (let i = gridOffset; i <= canvas.height; i += 50) { ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); }
            ctx.stroke();

            shockwaves.forEach(s => {
                ctx.save(); ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.strokeStyle = s.color; ctx.lineWidth = 5; ctx.globalAlpha = s.alpha; ctx.stroke(); ctx.restore();
            });

            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; });
            
            ctx.shadowBlur = 15; ctx.shadowColor = '#ffd700'; ctx.fillStyle = '#ffd700';
            coins.forEach(c => { if (c.active) { ctx.beginPath(); ctx.arc(c.x, c.y, c.size, 0, Math.PI*2); ctx.fill(); }});

            ctx.lineWidth = 3;
            obstacles.forEach(o => {
                if (o.type === 0) {
                    ctx.shadowBlur = 10; ctx.shadowColor = '#ff0055'; ctx.strokeStyle = '#ff0055';
                    ctx.strokeRect(o.x, o.y, o.w, o.h); 
                    ctx.beginPath(); ctx.moveTo(o.x, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.moveTo(o.x+o.w, o.y); ctx.lineTo(o.x, o.y+o.h); ctx.stroke();
                } 
                else if (o.type === 1) {
                    ctx.shadowBlur = 10; ctx.shadowColor = '#a700ff'; ctx.strokeStyle = '#a700ff';
                    ctx.strokeRect(o.x, o.y, o.w, o.h);
                    ctx.beginPath(); ctx.moveTo(o.x, o.y + o.h/2); ctx.lineTo(o.x+o.w, o.y + o.h/2); ctx.stroke();
                }
                else if (o.type === 2) {
                    ctx.shadowBlur = 10; ctx.shadowColor = '#ff9900'; ctx.strokeStyle = '#ff9900';
                    ctx.save();
                    ctx.translate(o.x + o.w/2, o.y + o.h/2);
                    ctx.rotate(o.angle);
                    ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h);
                    ctx.strokeRect(-o.w/4, -o.h/4, o.w/2, o.h/2);
                    ctx.restore();
                }
            });

            if (gameActive) {
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.tilt * Math.PI / 180);
                ctx.shadowColor = '#00f3ff'; ctx.shadowBlur = 20; ctx.fillStyle = '#000'; ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(0, -player.height/2); ctx.lineTo(player.width/2, player.height/2); ctx.lineTo(0, player.height/2 - 10); ctx.lineTo(-player.width/2, player.height/2); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.shadowColor = '#ff5e00'; ctx.fillStyle = '#ff5e00'; ctx.beginPath(); ctx.moveTo(-5, player.height/2 - 5); ctx.lineTo(5, player.height/2 - 5); ctx.lineTo(0, player.height/2 + (Math.random() * 20 + 10)); ctx.fill();
                ctx.restore();
            }
            
            ctx.shadowBlur = 0;
            if (!gameActive && (particles.length > 0 || shockwaves.length > 0)) {
                requestAnimationFrame(draw);
            }
        }

        function gameLoop() {
            if (!gameActive) return;
            try {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error(error);
                gameActive = false;
            }
        }

        async function saveScoreAndGoHome() {
            if (!db) return;
            const nameInput = document.getElementById('playerName');
            let name = nameInput.value.trim() || "Unknown";
            if (name.length > 12) name = name.substring(0, 12);
            
            const finalScore = Math.floor(score);
            const btn = document.getElementById('saveBtn');
            btn.disabled = true;
            btn.innerText = "UPLOADING...";
            try {
                await addDoc(collection(db, "scores"), { 
                    name: name, 
                    score: finalScore, 
                    time: finalTimeString, 
                    date: new Date() 
                });
                await fetchLeaderboard();
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('homeScreen').classList.remove('hidden');
            } catch (e) {
                console.error("Error adding score: ", e);
                alert("Score save failed. Check internet.");
                document.getElementById('gameOverScreen').classList.add('hidden');
                document.getElementById('homeScreen').classList.remove('hidden');
            }
            btn.disabled = false;
            btn.innerText = "SAVE & HOME";
        }

        function discardAndGoHome() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
        }

        async function fetchLeaderboard() {
            if (!db) { document.getElementById('leaderboardList').innerHTML = "Firebase Offline"; return; }
            const list = document.getElementById('leaderboardList');
            if(list.innerHTML === "") list.innerHTML = "Updating...";
            try {
                const q = query(collection(db, "scores"), orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                let html = "";
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const timeDisplay = data.time || "--:--"; 
                    
                    html += `
                    <div class="lb-row">
                        <span>#${rank} ${data.name}</span>
                        <span>${timeDisplay}</span>
                        <span>${data.score}</span>
                    </div>`;
                    rank++;
                });
                list.innerHTML = html || "No scores yet. Be the first!";
            } catch (e) { console.error(e); list.innerHTML = "Error loading scores."; }
        }

        // --- BUTTON LISTENERS (Dual Bindings for Reliability) ---
        const startBtn = document.getElementById('startBtn');
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', startGame);

        const saveBtn = document.getElementById('saveBtn');
        saveBtn.addEventListener('click', saveScoreAndGoHome);
        // no touchstart for save to avoid double submit, click is sufficient for forms usually

        document.getElementById('discardBtn').addEventListener('click', discardAndGoHome);
    </script>
</body>
</html>
